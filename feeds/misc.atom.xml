<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Do Not Disturb My Circles - misc</title><link href="https://donotdisturbmycircles.com/" rel="alternate"></link><link href="https://donotdisturbmycircles.com/feeds/misc.atom.xml" rel="self"></link><id>https://donotdisturbmycircles.com/</id><updated>2022-08-16T00:00:00+01:00</updated><entry><title>Inheritance is goto for polymorphism</title><link href="https://donotdisturbmycircles.com/inheritance-goto.html" rel="alternate"></link><published>2022-08-16T00:00:00+01:00</published><updated>2022-08-16T00:00:00+01:00</updated><author><name>Movpasd</name></author><id>tag:donotdisturbmycircles.com,2022-08-16:/inheritance-goto.html</id><summary type="html"></summary><content type="html">&lt;p&gt;Everyone likes to give inheritance a hard time these days. Compose, don't
inherit, so they say. Well, time for me to jump onto the bandwagon. Here is
reason #6701 why inheritance is a problem.&lt;/p&gt;
&lt;p&gt;Inheritance in traditional OOP introduces implicit single-dispatch polymorphism
at every call site. When you call &lt;code&gt;.myMethod()&lt;/code&gt; on &lt;code&gt;SomeClass someObject&lt;/code&gt;, you
may think you know what behaviour you're eliciting, but you actually don't.
Because if &lt;code&gt;SomeChildClass extends SomeClass&lt;/code&gt;, and later you or someone else
decides to &lt;code&gt;@override myMethod()&lt;/code&gt;, then the caller of &lt;code&gt;.myMethod()&lt;/code&gt; no longer
has any control over what happens.&lt;/p&gt;
&lt;p&gt;Contrast this with generics-based polymorphism. When I call a generic
&lt;code&gt;myProc&amp;lt;T&amp;gt;()&lt;/code&gt;, at the call site, I have full control over where control flow
goes. I know at compile time exactly what will be executed. This makes
&lt;code&gt;myProc&amp;lt;T&amp;gt;()&lt;/code&gt; nice and usable from the caller's perspective.&lt;/p&gt;
&lt;p&gt;Same thing for ad hoc polymorphism. When I call &lt;code&gt;myProc(float x)&lt;/code&gt;, I know that
it's not &lt;code&gt;myProc(String x)&lt;/code&gt; that will get run.&lt;/p&gt;
&lt;p&gt;(Not all inheritance has this problem, you specifically need dynamic dispatch,
i.e.: virtual methods. So this isn't as much of a problem in C++ for example,
since you know at the call site that unpredictable runtime polymorphism might
occur because you know can see the method is virtual.)&lt;/p&gt;
&lt;p&gt;Of course, the fact that you don't know where control flow is the whole &lt;em&gt;point&lt;/em&gt;
of OOP, right? Hide the implementation. Yes! Absolutely. Information hiding is
awesome. Modularity all the way. But, as has been pointed out by many before
me, the object just never seems to be the &lt;em&gt;right scale&lt;/em&gt; at which to create an
interface-implementation split. Modules are.&lt;/p&gt;
&lt;p&gt;This ends up incentivising code which is really hard to understand, where you
have to jump around between classes a lot. Because let's be honest: most
methods or procedures just don't have the kind of in-depth documentation of
exactly what it's supposed to do and which post-conditions need to be
maintained, information which is critical for a person &lt;code&gt;extend&lt;/code&gt;ing your class
in the future. So &lt;code&gt;TheirChildClass&lt;/code&gt; ends up violating that implicit
post-condition which callees of the method are quietly depending on.&lt;/p&gt;
&lt;p&gt;This reminds me of nothing less than the dreaded &lt;code&gt;goto&lt;/code&gt;. &lt;code&gt;goto&lt;/code&gt; is bad because
it creates an unstable relationship between the &lt;code&gt;goto&lt;/code&gt;er and the &lt;code&gt;goto&lt;/code&gt;ee. The
&lt;code&gt;goto&lt;/code&gt;er gets no guarantees about if, when, nor how execution will return to
it. This is &lt;em&gt;implicit control flow&lt;/em&gt;, because the &lt;code&gt;goto&lt;/code&gt; could send you anywhere
compared to the current statement, before or after, creating the potential for
complicated unexpected dependencies.&lt;/p&gt;
&lt;p&gt;With inheritance, you have &lt;em&gt;implicit polymorphism&lt;/em&gt;. Sure, you're still doing
structured programming, so at least you know the method will return. So there's
no uncertainty in the caller control flow. But there is unpredictability in
the &lt;em&gt;behaviour&lt;/em&gt; of the method call, which leaks upwards to make the caller
unpredictable as well.&lt;/p&gt;</content><category term="misc"></category><category term="code"></category></entry><entry><title>Software design is a lot like mathematics</title><link href="https://donotdisturbmycircles.com/code-like-maths.html" rel="alternate"></link><published>2022-08-13T00:00:00+01:00</published><updated>2022-08-13T00:00:00+01:00</updated><author><name>Movpasd</name></author><id>tag:donotdisturbmycircles.com,2022-08-13:/code-like-maths.html</id><summary type="html"></summary><content type="html">&lt;p&gt;I don't mean that programming is &lt;em&gt;mathematical&lt;/em&gt; (which it of course is), or that
mathematics is &lt;em&gt;mechanical&lt;/em&gt; (which it sometimes also is). I mean that the
actual process of software design and writing code is a lot like the process of
doing and creating mathematics.&lt;/p&gt;
&lt;p&gt;In both cases, you are trying to define the right structures so that they do the
right thing. In software design, you are defining the parts and interactions of
a complex system, to get it to produce the functionality desired. (If that
sounds gross and OOP to you, replace "parts and interactions" with "modules and
dependencies".) In mathematics, you're defining mathematical objects so that
they do something interesting and trying to prove it. In both cases, it's
trying to find the right definitions for the job.&lt;/p&gt;
&lt;p&gt;One of the key differences is that mathematicians &lt;em&gt;want&lt;/em&gt; their definitions to do
something exciting and unexpected. If a piece of software does something of the
sort, we usually call that a bug.&lt;/p&gt;
&lt;p&gt;But not always. There are certain software design approaches which value the
unexpected, usually by harnessing the emergence of functionality from the
juxtaposition of many small modules. Like the UNIX philosophy. Or functional
programming approaches, where power often comes from &lt;a href="https://stackoverflow.com/questions/6016271/"&gt;combinatoric explosion&lt;/a&gt; of definable functions. If you
had a reductionist bent, you could argue that mathematics is just the
exploration of the uncomputably large space of statements that may be derived
from axioms and logical inference rules. Good definitions are those which
make that space most accessible.&lt;/p&gt;
&lt;p&gt;I think there is a key takeaway from this for software design. A lot of
well-designed code is well-designed because it's designed with the pedantry and
aesthetic sensibilities of a mathematician. A well-designed piece of code
naturally covers its edge cases by the same token as a well-designed
definition.&lt;/p&gt;</content><category term="misc"></category><category term="code"></category><category term="maths"></category><category term="short"></category></entry><entry><title>You don't have furniture</title><link href="https://donotdisturbmycircles.com/dust.html" rel="alternate"></link><published>2022-08-06T00:00:00+01:00</published><updated>2022-08-06T00:00:00+01:00</updated><author><name>Movpasd</name></author><id>tag:donotdisturbmycircles.com,2022-08-06:/dust.html</id><summary type="html"></summary><content type="html">&lt;p&gt;Dust forms through the progressive degradation of the solids around us. It's an
uncomfortable reminder of a microscopic world that not only exists all around
us, but interacts with the more familiar macroscopic.&lt;/p&gt;
&lt;p&gt;In my scientific education, the idea that has changed my perspective on the
world around me most profoundly might have been my introductory materials
science course I took in my first year of university. It was quite cursory, of
course, but it made me realise that the world around me was this endless flux
of atoms and structure. A steel rod is not "merely" made of steel. It is steel
atoms arranged in an astoundingly complex arrangement of structure upon
structure upon microstructure.&lt;/p&gt;
&lt;p&gt;It was a moment that psychologists might call an "accommodation": The expansion
of one's internal model of reality to &lt;em&gt;accommodate&lt;/em&gt; new information that cannot
fit within one's existing models. I live for those moments. Moments when you
realise that you've been taking an idea for granted, an idea that in truth
merits closer inspection, and you perform that closer inspection and you become
a bigger person for it.&lt;/p&gt;
&lt;p&gt;I suppose the thing I'd been taking for granted was &lt;em&gt;solidness&lt;/em&gt;; &lt;em&gt;rigidity&lt;/em&gt;;
what it meant for an &lt;em&gt;object&lt;/em&gt; to be an object; or perhaps even &lt;em&gt;thingness&lt;/em&gt;, the
fact of being a single unified entity. A cup is a cup, and I move that whole
cup around when I move it. But in fact, it isn't. Rigidity is a concept that
exists only at a particular scale of size and stiffness. Try to pick up a metal
sheet a hundred metres across, or to grab water as if it were solid, and the
concept breaks down.&lt;/p&gt;
&lt;p&gt;I think this is quite a common learning obstacle in physics education. On
physics question-answer forums, I can't count the number of confusions I've
seen about reference frames, which goes something like this -- "if I'm in a
train, I'm in its reference frame; but if I leave it, at what point do I leave
the reference frame?" A question that I'm certain anyone who has studied
physics has had to ask themselves. Of course, the answer is that the reference
frame has nothing to do with the train's geometric boundaries. It's not a thing
you can be "in" or "out" of, the way you can be in or out of a room.&lt;/p&gt;
&lt;p&gt;In a similar vein, the "what if I have a rod a lightyear across and push one end
of it?" The expectation is that the far end of the rod should immediately begin
to move in response to the push, and it stems from a conceptualisation of the
rod as One Thing, with its associated concepts of indivisibility and rigidity.&lt;/p&gt;
&lt;p&gt;These are all questions I've asked myself at some point in my education, and
found partially satisfactory answers to, but it wasn't until that moment of
accommodation during some first-year Materials Science uni lecture that it all
clicked together. It was a &lt;em&gt;Matrix&lt;/em&gt; moment: "There is no spoon." Indeed, there
is no rod, there is no train, and there is no cup. There are only atoms and
void.&lt;/p&gt;
&lt;p&gt;Dust. It arises from the progressive degradation of the solid matter in our
environment. (Is it an inevitable consequence of the 2nd law of thermodynamics?
Indeed, to free up material from its rigid confinement in a solid material
structure is to allow its degrees of freedom to move more independently than
when it was in it. So it has more entropy, or at least, the potential for more
entropy. A pile of sand has more entropy than a chunk of quartzite.)&lt;/p&gt;
&lt;p&gt;Have you ever noticed your clothes getting a little threadbare, or the patterns
printed upon it degrading? Where did the threads of your once &lt;em&gt;threadplenty&lt;/em&gt;
favourite T-shirt go? They were pulverised. Perhaps not entire threads, perhaps
only the exterior layers of the threads still holding onto self-contained
Thingness, but pulverised, turned to dust on the counter, lint in the lint
trap, dust mite breakfast! (Or is it? Do dust mites eat fabric shreds?
Unsure.)&lt;/p&gt;
&lt;p&gt;The thingness of the things around us is an illusion. You don't have furniture.
There are atoms, and you think they are furniture. The exterior layers of the
wood of your shelf is incessantly sloughing off into the entropic soup we
unknowingly bathe in. With every scratch, every nick, every blemish, particles
of lignin are shredded and thrust into the air, where they will roll around and
degrade into chaotic strands of polymers, and from there through biological or
chemical processes broken into their constituent sugars and back out into the
ecological and geological cycles of the Earth.&lt;/p&gt;
&lt;p&gt;...&lt;/p&gt;
&lt;p&gt;I don't like dust. I'm allergic.&lt;/p&gt;
&lt;p&gt;I should get back to dusting.&lt;/p&gt;</content><category term="misc"></category><category term="writing"></category><category term="physics"></category></entry><entry><title>Inertial forces are intrinsically Galilean</title><link href="https://donotdisturbmycircles.com/inertial-forces-invariant.html" rel="alternate"></link><published>2022-08-01T00:00:00+01:00</published><updated>2022-08-01T00:00:00+01:00</updated><author><name>Movpasd</name></author><id>tag:donotdisturbmycircles.com,2022-08-01:/inertial-forces-invariant.html</id><summary type="html"></summary><content type="html">&lt;p&gt;The defining property of inertial forces is that they don't affect Galilean invariants: distance and
duration.&lt;/p&gt;
&lt;p&gt;This &lt;em&gt;requires&lt;/em&gt; that they be proportional to mass, but that doesn't fully characterise them.&lt;/p&gt;
&lt;p&gt;The invariant definition can probably be proven to be equivalent to the more intuitive but arguably
less fundamental definition, that a time-dependent SO(3) transformation can remove them entirely.&lt;/p&gt;
&lt;p&gt;We can imagine some Galilean spacetime coordinate systems which introduce forces that might be
described as "hyperinertial". These would violate the integrity of rigid bodies -- there's probably
some connection to SO(3) here as well, what with rigid bodies being determined by an element of SO
(3) and a translation from the origin.&lt;/p&gt;
&lt;p&gt;I think Lorentzian relativity can't have inertial forces the way Galilean relativity does.
Invariance of the spacetime interval fixes the Poincaré group (Lorentz group if origin fixed)
completely all on its own, whereas distance and duration &lt;em&gt;doesn't&lt;/em&gt; fix the Galilean group. You need
to impose linearity on top. This must have something to do with the fact that Galilean symmetry
decomposes directly between space and time, whereas Lorentzian only semidirectly.&lt;/p&gt;</content><category term="misc"></category><category term="short"></category><category term="physics"></category></entry><entry><title>Why multiple time dimensions don't work</title><link href="https://donotdisturbmycircles.com/multiple-time-dimensions.html" rel="alternate"></link><published>2022-07-30T00:00:00+01:00</published><updated>2022-07-30T00:00:00+01:00</updated><author><name>Movpasd</name></author><id>tag:donotdisturbmycircles.com,2022-07-30:/multiple-time-dimensions.html</id><summary type="html"></summary><content type="html">&lt;p&gt;In Lorentzian relativity, the (strict) past and future light cones are totally
disjoint, and no transformation within the part of SO&amp;NoBreak;(1, 3) connected
with the identity can mix these two sets.&lt;/p&gt;
&lt;p&gt;This property is so important that this part of SO&amp;NoBreak;(1, 3) is sometimes
called the "orthochronous" Lorentz group. It's what guarantees that the causal
ordering of events in spacetime is Lorentz invariant, and thus "objective".
(I'm tempted to bet that this also enforces some sort of existence and
uniqueness requirement on Cauchy initial value problems in Lorentzian
spacetime, further formalising the intuition behind causality, but don't quote
me on that.)&lt;/p&gt;
&lt;p&gt;Space does not have such a linear ordering. A rotation continuously connected to
the identity in SO&amp;NoBreak;(3) can rotate the +x axis into the -x axis.
Therefore, there can be no causal ordering of events in space. This also
reflects our intuition about causality: my left can be your right, but if a
particle's past from my perspective is its future from yours, we will disagree
about the order of causality, which would be a problem.&lt;/p&gt;
&lt;p&gt;The reason space doesn't have such a linear ordering is because there are more
than two space dimensions, which means that you can &lt;em&gt;rotate&lt;/em&gt; space. You can't
rotate time alone (in 1+3 dimensions) -- you can only rotate it along with
space (Lorentz boosts). The rotation group
SO&amp;NoBreak;(1) is trivial.&lt;/p&gt;
&lt;p&gt;If you had more than one time dimension, then you wouldn't really have a
spacetime, you'd have a two conjoined spaces of potentially different
dimensions, distinguished by their relative sign in the metric. Your "time"
dimension is nondeterministic. (Again, probably something here about Cauchy
initial value problems, but again, don't quote me on it.)&lt;/p&gt;
&lt;p&gt;(Of course, this ordering is ambiguous as to which direction is future and which
is past, and so doesn't imply an arrow of time. T symmetry still exists.)&lt;/p&gt;</content><category term="misc"></category><category term="short"></category><category term="physics"></category></entry></feed>